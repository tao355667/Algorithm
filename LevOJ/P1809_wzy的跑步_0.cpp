/*
P1809 wzy的跑步
====关键词===================================================
1.动态规划（第i步结果可从它前面的结果推出）
====关键词===================================================
====题目===================================================
题目描述
wzy 在跑步，由于昨天下雨了，所以跑道上某些位置堆积了雨水。wzy 并不希望自己踩到水坑，所以当他将要踩到水坑时候他会选择跳过去。 具体的，跑道可以抽象为长度为n 的序列，wzy 从位置1 出发，目的地是到达位置n。跑道上会有m 个位置存在积水，他每次可以跳1 到k 单位长度正整数的距离，问wzy 最少可以踩到几次水坑到达位置n。
输入描述
输入第一行三个正整数n，m，k，分别代表路径的长度，积水的个数以及wzy 一次最远可以跨多远。
第二行共 m 个正整数ai ，分别代表第i 个水坑的位置。
输出描述
输出共一行，一个正整数，表示wzy 至少踩到几次水坑才能到达位置n。
样例输入
Copy to Clipboard
6 3 2
2 3 5
样例输出
Copy to Clipboard
1
样例解释
位置2，3，5 存在水坑。wzy 最初在位置1，他只能到达位置2，3。一种可行的走法为1−2−4−6，共踩1 次水坑。显然这是踩最少次水坑的方式之一。
数据规模
n≤10000，m≤n，k≤50。
====题目===================================================
*/

#include <iostream>
#include <cstring>
using namespace std;
const int N = 10010;
int n, m, k; //路径长度，积水个数，wzy一次可以跨多远
int a[N];    // a[i]=1表示第i个位置上有积水
int dp[N];
int main()
{
    while (cin >> n >> m >> k)
    {
        //变量初始化
        memset(a, 0, sizeof(a));
        memset(dp, 0, sizeof(dp));
        for (int i = 1; i <= m; i++)
        {
            int water;
            cin >> water;
            a[water] = 1;
        }
        //题解
        dp[1] = a[1]; //第一个位置
        for (int i = 2; i <= n; i++)
        {
            int minstep = dp[i - 1];
            for (int j = 1; j <= k; j++)
            {
                if (i - j < 1) // i-j表示当前可走向i位置的下标
                    continue;
                // printf("a[%d]=%d\n", i - j, a[i - j]);
                minstep = min(dp[i - j], minstep);
            }
            // printf("dp[%d]=%d\n", i, minstep + a[i]);
            dp[i] = minstep + a[i];
        }
        //输出答案
        cout << dp[n] << endl;
    }

    return 0;
}