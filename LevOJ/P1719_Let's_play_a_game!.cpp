/*
P1719 Let's play a game!
====关键词===================================================
贪心
别人的题解：https://www.dianjilingqu.com/319087.html
贪心做法，记录下每个指定值到自己前面的那个2的次方的距离，若在2的次方位置上，则可以直接删除，就是操作次数加1。

　　不在2的次方上的话，有2种情况，第一种，已经进行删除的操作数，大于删除该数所需的操作数，直接操作数加1即可，也就是直接删掉。怎么理解这种情况呢，我们可以这样想，当前面删除时，后面的数会向前移，因为要删除的操作数，大于删除该数所需的操作数，那么正好当该数移动到2的次方位置上时，我们对它进行删除。

　　第二种情况，已经进行删除的操作数，小于删除该数所需的操作数。我们取这个数所需的操作数。这个可以这样理解，当前面的数删除完成时，这个数已经快到能被删除的地方，那么再加上几次操作即可把这个数也删掉，这两次操作的数量加起来也就是要删除的这个数的操作数。
====关键词===================================================
====题目===================================================
题目描述
现有一包含n 个数的序列A1,A2,A3,...,An，给定一个定值k.
每次我们可以选择数列中一个下标为 2 的次幂的元素（如A1,A2,A4,A8...)将其删除出数列（删除后，其后的所有元素会自动前移一格）。
问最少进行多少次操作，能将序列中所有值为k的元素删除？
输入描述
第一行两个整数n,k
第二行
n 个整数，A1,A2,A3,...,An
输出描述
第一行一个整数，为最少操作次数。
样例输入 1
5 2
1 2 4 2 5
样例输出 1
2
样例输入 2
5 2
1 2 2 2 2
样例输出 2
4
====题目===================================================
*/
#include <iostream>
#include <algorithm>
const int N = 300010;
using namespace std;
int n, k;       // 元素个数，要删除的数
int base = 1;   // 小于下标值的最大2的次方值
int a[N], d[N]; // 存储元素，删除每个元素时需要的附带操作
int sum, ex;    // 删除元素的次数，需要的最大附带操作数目
int main()
{
    // 读数
    cin >> n >> k;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    // 题解
    for (int i = 1; i <= n; i++)
    {
        if (i > base)
        {
            base *= 2;
        }
        if (a[i] == k)
        {
            if (base > i)
            {
                base /= 2;
            }      // 此时base<=i
            sum++; // 删除了几次元素
            // i-base：还需要删除几次
            // sum-1：删除这个数“之前”进行了几次删除操作
            // 若i-base<=sum-1说明当前面删除时，后面的数会向前移到正确位置，可以执行删除操作
            // 若i-base>sum-1说明需要额外的操作数量，值为i-base-(sum-1)
            d[sum] = i - base - sum + 1;
            ex = max(ex, d[sum]);
        }
    }
    // 输出答案
    cout << sum + ex << endl;
    return 0;
}