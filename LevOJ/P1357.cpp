/*
P1357 食物链(一)
====关键词===================================================
被捕食者->捕食者
dfs，暴力搜索，拓扑排序
====关键词===================================================
====题目===================================================
1. 数一数，在这个食物网中最长的食物链包含的物种数是 ( )
......
现在给你 n 个物种和 m 条能量流动关系，求其中的食物链条数。
物种的名称为从 1 到 n 编号，m 条能量流动关系形如
a1 b1
a2 b2
a3 b3
……
am−1 bm−1
am bm
其中 ai bi 表示能量从物种 ai 流向物种 bi，即 ai 和 bi 之间存在捕食关系，且 ai 是被捕食者， bi 是捕食者。一条食物链是从顶到底的，即从能量流向的起点到终点。如图中的 1－＞3－＞4 就是一条食物链，而 1－＞3 则不是。
一条食物链至少包含两种生物。
输入描述
多组输入，每组第一行两个正整数 n 和 m。0 < n, m <= 1000
接下来 m 行每行两个整数 ai bi 表示 m 个捕食关系。
(数据保证输入数据不含环状结构，且不会有重复的能量流动关系出现)
输出描述
一个整数即食物网中的最长的食物链包含的生物数。
样例输入
Copy to Clipboard
10 16
1 2
1 4
1 10
2 3
2 5
4 3
4 5
4 8
6 8
7 6
7 9
8 5
9 8
10 6
10 7
10 9
样例输出
Copy to Clipboard
6
样例解释
输入的图就是上面题目描述的那个图。
各个物种的编号依次为：
草 <->1 兔 <->2 狐 <->3 鼠 <->4 猫头鹰 <->5 吃虫的鸟 <->6 蜘蛛 <->7 蛇 <->8 青蛙 <->9 食草昆虫 <->10。
最长的食物链为：1->10->7->6->8->5。
====题目===================================================
*/
#include <cmath>
#include <cstring>
#include <string>
#include <iostream>
using namespace std;
const int N = 1001; //数组大小
int n, m;           // n个结点，m个弧
int ans, cnt;       // ans:答案。cnt：到达结点后经过的结点数量（包括当前结点）
int in[N];          //结点的入度
int out[N];         //结点的出度
int g[N][N];        //用矩阵存图
int start, end_;    //接收数据，中转
/*
u：当前起点
*/
void dfs(int u)
{
    for (int i = 1; i <= n; i++)
    { //分支，找到它指向的结点，进一步搜索（dfs）
        if (g[u][i] == 0)
            ans = max(ans, cnt);
        else
        {
            cnt++; //路径数+1
            dfs(i);
            cnt--; //路径数-1
        }
    }
}
int main()
{
    while (scanf("%d%d", &n, &m) != EOF)
    { //多组输入
        //变量初始化
        ans = cnt = 0;
        memset(in, 0, sizeof(in));
        memset(out, 0, sizeof(out));
        memset(g, 0, sizeof(g));
        //读数据
        for (int i = 1; i <= m; i++)
        {
            scanf("%d%d", &start, &end_);
            g[start][end_] = 1; //将弧存入图中
            out[start]++;       //出度加1
            in[end_]++;         //入度加1
        }
        //题解
        for (int i = 0, k = 0; i < n; i++)
        {
            if (in[i] == 0)
                dfs(i);
        }
        printf("%d\n", ans + 1); //路径+1==点
    }
    return 0;
}
