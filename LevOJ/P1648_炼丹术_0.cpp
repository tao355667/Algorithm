/*
P1648 炼丹术
====关键词===================================================
1.暴力：求幂集，判断是否符合标准，计数
2.单方和其稳定剂构成有向图,（由于输入是全排列，故图必然由若干个环组成）,找图中有几个环,再求（幂集数-1）（去掉空集）
    2.1 第一次没过，因为要在mypow中对结果取模（不用开longlong），而非最后对ans取模（过不了）
3.模板：并查集
====关键词===================================================
====题目===================================================
题目描述
三水最近在学习炼丹术。但是众所周知炼丹术是一门危险的学科，需要大量的调参才能保证安全。好在三水在洗衣机里面找到了一张失传已久的图纸，里面记录了若干种材料的药性。这张图纸上记录了n 种不同的药材，对于每种药材，都需要恰好一种药材来使其稳定 (这种药材可能是其自身，即这种药材本身就很稳定)。三水想知道，通过这张图纸，可以得到多少种不同的稳定的丹方。保证每种药材只会作为稳定剂出现一次。
我们认为一个丹方是从n 种药材中选择若干种 (不为0 )，两个丹方被认为是不同的当且仅当存在一种药材在其中一个丹方中且不在另一个中。我们称一个丹方是稳定的，当且仅当所有出现在丹方中的药材的稳定剂也在药材中。
因为输出结果可能很大，所以答案对 998244353 取模。
输入描述
第一行一个数字n ， 表示有n(1⩽n⩽10^6) 种不同的药材。 接下来一行n 个数字，第i 数字ai​(1⩽ai⩽n) 表示药材i 的稳定剂是ai，保证输入是1 到n 的一个全排列。
输出描述
一个整数
n ，表示答案对 998244353 取模的结果。
样例输入
Copy to Clipboard
6
2 3 4 5 6 1
样例输出
Copy to Clipboard
1
====题目===================================================
*/
#include <iostream>
#include <cmath>
using namespace std;
const int N = 1e6 + 10;
const int MOD = 998244353;
const int INF = 0x3f3f3f3f;
int n;           //几个结点
int a[N];        //结点稳定剂
bool visited[N]; //结点是否被访问
int ring;        //环数
int ans;         //结果
int mypow(int x)
{ // 求2的x次方（由于取了模，不需要开longlong）
    int ret = 1;
    while (x--)
    {
        ret = (ret * 2) % MOD; //结果取模
    }
    return ret;
}
void find_ring()
{ //计算环数
    int ss, s, e;
    //从第一个结点开始
    for (int i = 1; i <= n; i++)
    {
        if (!visited[i])
        {
            ring++; //环数+1
            ss = i;
            s = i;
            e = a[s];
            visited[i] = true;
            while (ss != e)
            { //将处于同一个环的结点都标记上
                s = e;
                e = a[s];
                visited[s] = true;
            }
        }
    }
}
int main()
{
    //读数
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    //题解
    find_ring();
    ans = mypow(ring) - 1;
    //输出答案
    printf("%d", ans);
    return 0;
}