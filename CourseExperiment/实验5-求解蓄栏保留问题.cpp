/*
实验5-求解蓄栏保留问题
农场有n头牛，每头牛会有一个特定的时间区间[b，e]在蓄栏里挤牛奶，并且一个蓄栏里任何时刻只能有一头牛挤奶。
现在农场主希望知道最少蓄栏能够满足上述要求，并给出每头牛被安排的方案。对于多种可行方案，输出一种即可。
题解：
（1）该问题与活动安排问题类似，可用贪心算法求解，相当于多次求解活动安排问题
（2）将每头牛的挤奶时间看作一个活动，将所有活动这样排序：结束时间相同的按照开始时间递增排序，结束时间不同的按照结束时间递增排序。
之后再次使用贪心思想，多次选出最大兼容活动子集，由于每一次得到的活动子集都是最大的，所以最后得到的活动子集数目就是最少的。
（3）按照顺序，根据相容性规则，从头到尾选择牛，得到一个新的最大兼容活动子集
（4）重复步骤3，直到牛被选完
（5）最大兼容活动子集的个数就是最少蓄栏个数（步骤3的执行次数）

*/
#include <cstdio>
#include <cstring>
#include <algorithm>
using std::sort;
const int MAX = 1000;
//问题表示
struct Cow //奶牛的类型声明
{
    int no;                            //牛编号
    int b;                             //起始时间
    int e;                             //结束时间
    bool operator<(const Cow &s) const //重载<关系函数
    {
        if (e == s.e) //结束时间相同按开始时间递增排序
            return b <= s.b;
        else //否则按结束时间递增排序
            return e <= s.e;
    }
};
int n = 5;
Cow A[] = {{0}, {1, 1, 10}, {2, 2, 4}, {3, 3, 6}, {4, 5, 8}, {5, 4, 7}};
//下标0不用
//求解结果表示
int ans[MAX]; // ans[i]表示第A[i].no头牛的蓄栏编号
void solve()  //求解最大兼容活动子集个数
{
    sort(A + 1, A + n + 1);      // A[1..n]按指定方式排序
    memset(ans, 0, sizeof(ans)); //初始化为0
    int num = 1;                 //蓄栏编号
    for (int i = 1; i <= n; i++) // i、j均为排序后的下标
    {
        if (ans[i] == 0) //第i头牛还没有安排蓄栏
        {
            ans[i] = num; //第i头牛安排蓄栏num
            // 找与A[i]兼容的活动
            int preend = A[i].e;             //前一个兼容活动的结束时间
            for (int j = i + 1; j <= n; j++) //查找一个最大兼容活动子集
            {
                if (A[j].b > preend && ans[j] == 0)
                {
                    ans[j] = num;    //将兼容活动子集中活动安排在num蓄栏中
                    preend = A[j].e; //更新结束时间
                }
            }
            num++; //查找下一个最大兼容活动子集,num增1
        }
    }
}
int main()
{
    solve();
    printf("实验5-求解蓄栏保留问题\n求解结果\n");
    for (int i = 1; i <= n; i++)
        printf(" 牛%d安排的蓄栏: %d\n", A[i].no, ans[i]);
    return 0;
}
